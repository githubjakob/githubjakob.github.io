<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-10-30T21:14:59+01:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jakob Zanker</title><subtitle>Software Developer, based in Munich
</subtitle><author><name>Jakob Zanker</name></author><entry><title type="html">Implementing an Auth0 Client Application from Scratch (OAuth Web Message Response Mode - Part 2)</title><link href="http://localhost:4000/oauth-web-message-response-mode-in-practice-with-auth0.html" rel="alternate" type="text/html" title="Implementing an Auth0 Client Application from Scratch (OAuth Web Message Response Mode - Part 2)" /><published>2024-07-21T00:00:00+02:00</published><updated>2024-07-21T00:00:00+02:00</updated><id>http://localhost:4000/oauth-web-message-response-mode-in-practice-with-auth0</id><content type="html" xml:base="http://localhost:4000/oauth-web-message-response-mode-in-practice-with-auth0.html">&lt;p&gt;In &lt;a href=&quot;/oauth-web-message-response-mode.html&quot;&gt;part one&lt;/a&gt;
we explored how the OAuth response mode &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;web_message&lt;/code&gt; works and how it is using the post message 
web API to return the authorization code to the client application.&lt;/p&gt;

&lt;p&gt;In this second part I want to show how this works in detail. For demonstration purposes, we will implement an OAuth client application from scratch using Auth0 as an authorization server.&lt;/p&gt;

&lt;p&gt;The final result can be found here:
&lt;a href=&quot;https://githubjakob.github.io/oauth-web-message-debugger/&quot;&gt;https://githubjakob.github.io/oauth-web-message-debugger/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/auth0/screenshot.png&quot; alt=&quot;Screenshot of the demo application we will build&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To gain some better understanding, we will not use the Auth0 Javascript SDK, but implement all the required steps for the OAuth / OIDC authentication flow ourselves.&lt;/p&gt;

&lt;p&gt;There are a couple of demo applications out there for debugging OAuth auth servers:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;For example, the &lt;a href=&quot;https://www.oauth.com/playground/authorization-code.html&quot;&gt;OAuth Playground&lt;/a&gt; is really useful for understanding the basics behind OAuth and different OAuth flows.&lt;/li&gt;
  &lt;li&gt;Also, &lt;a href=&quot;https://oauthdebugger.com/]&quot;&gt;OAuth Debugger&lt;/a&gt; is a nice little tool to interact with your authorization server&lt;/li&gt;
  &lt;li&gt;without implementing it in your actual application.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But I could not find one that supported the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;web_message&lt;/code&gt; response mode. So let’s implement our own OAuth client!&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;In part one we already gave a high level description of the required steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The client application opens the popup with the link to the authorization server.&lt;/li&gt;
  &lt;li&gt;Our application will start listening to the post message event.&lt;/li&gt;
  &lt;li&gt;The user authenticates in the popup.&lt;/li&gt;
  &lt;li&gt;The authorization sends the authorization code back to our application via the post message event.&lt;/li&gt;
  &lt;li&gt;Our application receives the authorization code and exchanges it for the access and id token.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You can find the full implementation here and follow along in the code, while we go through each of the steps:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/githubjakob/oauth-web-message-debugger&quot;&gt;https://github.com/githubjakob/oauth-web-message-debugger&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;implementation-of-the-oauth-client-application&quot;&gt;Implementation of the OAuth client application&lt;/h2&gt;

&lt;p&gt;We will build a demo application for debugging purposes and integrate it with Auth0 as auth provider.&lt;/p&gt;

&lt;h3 id=&quot;building-the-url-to-the-authorization-server&quot;&gt;Building the url to the authorization server&lt;/h3&gt;

&lt;p&gt;The first step is to build the URL to the authorization server to start the flow.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.1&quot;&gt;standard defines only two required arguments&lt;/a&gt; for the authorization url:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;response_type&lt;/code&gt; must be set to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;code&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;client_id&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;opening-the-link-in-a-popup&quot;&gt;Opening the Link in a popup&lt;/h3&gt;

&lt;p&gt;The next step is easy: We open the URL in a popup&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;window.open(url, &apos;childWindow&apos;, &apos;width=600,height=400&apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;subscribing-to-the-message-event&quot;&gt;Subscribing to the message event&lt;/h3&gt;

&lt;p&gt;Now we need to register for the post message event. In the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;web_message&lt;/code&gt; response mode the auth server will send us the response via this event:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;window.addEventListener(&apos;message&apos;, (event) =&amp;gt; {
    console.log(&quot;Message&quot;, event?.data)
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;code-exchange&quot;&gt;Code Exchange&lt;/h3&gt;

&lt;p&gt;Since we use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;code&lt;/code&gt; we need to exchange the authorization code that we received via the message event to get 
the access, refresh and id token.&lt;/p&gt;

&lt;p&gt;Again, the &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3&quot;&gt;standard defines the POST endpoint and the required payload&lt;/a&gt; for the token exchange: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/oauth/token&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grant_type&lt;/code&gt; REQUIRED.  Value MUST be set to “authorization_code”.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;code&lt;/code&gt;  The authorization code received from the
authorization server.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;redirect_uri&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;client_id&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The response of this request will contain the access, refresh, and id token.&lt;/p&gt;

&lt;h3 id=&quot;parse-the-id-token&quot;&gt;Parse the ID Token&lt;/h3&gt;

&lt;p&gt;The following is optional, but it makes sense if we want to look into the data we get back from the auth server /token endpoint:
we need to decode the JWT tokens.&lt;/p&gt;

&lt;p&gt;To do this, we can head over to &lt;a href=&quot;https://jwt.io/#debugger-io&quot;&gt;https://jwt.io/#debugger-io&lt;/a&gt; and paste the token there.&lt;/p&gt;

&lt;p&gt;Et viola, we completed the flow!&lt;/p&gt;

&lt;h2 id=&quot;testing-the-implementation-with-auth0&quot;&gt;Testing the implementation with Auth0&lt;/h2&gt;

&lt;p&gt;Now let’s test the implementation with Auth0.&lt;/p&gt;

&lt;p&gt;We need to create an application in Auth0 and configure a few options.&lt;/p&gt;

&lt;p&gt;After registration and signup in Auth0 we need to create an application:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/auth0/auth0-create-application.png&quot; alt=&quot;Auth0 application creation flow&quot; /&gt;&lt;/p&gt;

&lt;p&gt;For our purpose, we select “Javascript”:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/auth0/auth0-create-application-2.png&quot; alt=&quot;Create an OAuth application in Auth0&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/auth0/auth0-create-application-3-javascript.png&quot; alt=&quot;Select Javascript&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We have to configure two options:&lt;/p&gt;

&lt;p&gt;First, the allowed origin:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/auth0/auth0-allowed-origin.png&quot; alt=&quot;Configure the allowed origin in the Auth0 application&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Second, the allowed callback:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/auth0/auth0-configure-callback.png&quot; alt=&quot;Configure the allowed callback in the Auth0 application&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now we need to copy two values in the form of our demo application:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ClientId&lt;/li&gt;
  &lt;li&gt;Application Url&lt;/li&gt;
  &lt;li&gt;The redirect url&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/auth0/auth0-clientid-url.png&quot; alt=&quot;Copy the client id and application url&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Clicking the “authorize” button opens the url in the popup:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/auth0/auth0-open-link.png&quot; alt=&quot;Click the authorize button to open the link&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We can register a new user:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/auth0/auth0-register.png&quot; alt=&quot;Register a new user in Auth0&quot; /&gt;&lt;/p&gt;

&lt;p&gt;After we finish the registration, we see that our demo application received the auth code via the message event:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/auth0/auth0-auth-code.png&quot; alt=&quot;Demo application receives the auth code&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We can exchange the auth code for the id token:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/auth0/auth0-id-token.png&quot; alt=&quot;Exchange the auth code for the id token&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And finally, parse the id JWT token to display the content:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/auth0/auth0-jwt.png&quot; alt=&quot;Parse the id token&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;comparing-with-the-auth0-javascript-sdk&quot;&gt;Comparing with the Auth0 Javascript SDK&lt;/h2&gt;

&lt;p&gt;To wrap up this post, let’s compare our implementation with how the Auth0 SDK does it.&lt;/p&gt;

&lt;p&gt;The source code for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auth0-spa-js&lt;/code&gt; is on GitHub: https://github.com/auth0/auth0-spa-js/blob/main/src/Auth0Client.ts&lt;/p&gt;

&lt;p&gt;The relevant part is the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;loginWithPopup&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;Looking at the code, we can see that Auth0 SDK &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auth0-spa-js&lt;/code&gt; is implementing the same logic that we implemented in the demo.&lt;/p&gt;

&lt;p&gt;First building the authorization url using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;response_mode=web_message&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const params = await this._prepareAuthorizeUrl(
      options.authorizationParams || {},
      { response_mode: &apos;web_message&apos; },
      window.location.origin
    );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Source &lt;a href=&quot;https://github.com/auth0/auth0-spa-js/blob/main/src/Auth0Client.ts#L372C7-L372C40&quot;&gt;https://github.com/auth0/auth0-spa-js/blob/main/src/Auth0Client.ts#L372C7-L372C40&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Then setting up the event listener for the message event in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;runPopup&lt;/code&gt; function:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;window.addEventListener(&apos;message&apos;, popupEventListener);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Source: &lt;a href=&quot;https://github.com/auth0/auth0-spa-js/blob/main/src/utils.ts#L136&quot;&gt;https://github.com/auth0/auth0-spa-js/blob/main/src/utils.ts#L136&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Finally exchanging the code for the token&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;await this._requestToken(
      {
        code: codeResult.code as string,
        ///...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Source: &lt;a href=&quot;https://github.com/auth0/auth0-spa-js/blob/main/src/Auth0Client.ts#L394&quot;&gt;https://github.com/auth0/auth0-spa-js/blob/main/src/Auth0Client.ts#L394&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;In this blog post we walked through the complete OAuth authentication flow for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;web_message&lt;/code&gt; response mode.&lt;/p&gt;

&lt;p&gt;We implemented a little demo client application and tested it together with Auth0 as authorization server.&lt;/p&gt;

&lt;p&gt;You can find the complete code here on my Github: &lt;a href=&quot;https://github.com/githubjakob/oauth-web-message-debugger&quot;&gt;https://github.com/githubjakob/oauth-web-message-debugger&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The OAuth demo client application is hosted here: &lt;a href=&quot;https://githubjakob.github.io/oauth-web-message-debugger/&quot;&gt;https://githubjakob.github.io/oauth-web-message-debugger/&lt;/a&gt;&lt;/p&gt;</content><author><name>Jakob Zanker</name></author><summary type="html">In part one we explored how the OAuth response mode web_message works and how it is using the post message web API to return the authorization code to the client application.</summary></entry><entry><title type="html">Exploring OAuth Web Message Response Mode: Authentication via Popup</title><link href="http://localhost:4000/oauth-web-message-response-mode.html" rel="alternate" type="text/html" title="Exploring OAuth Web Message Response Mode: Authentication via Popup" /><published>2024-07-07T00:00:00+02:00</published><updated>2024-07-07T00:00:00+02:00</updated><id>http://localhost:4000/oauth-web-message-response-mode</id><content type="html" xml:base="http://localhost:4000/oauth-web-message-response-mode.html">&lt;p&gt;I recently came across an interesting variation of an OAuth / OpenId Connect authentication flow: OAuth Authentication via a Popup.&lt;/p&gt;

&lt;p&gt;In this flow, the client application opens a popup window showing the login form of the authorization server. 
After the user logs in successfully, the popup window closes and the client application in the parent window receives the user id.
How does this work?&lt;/p&gt;

&lt;p&gt;As we will see, this flow makes use of the web message response mode of OAuth, which relies on the post message web API.&lt;/p&gt;

&lt;p&gt;The protocol is &lt;a href=&quot;https://www.ietf.org/archive/id/draft-meyerzuselha-oauth-web-message-response-mode-00.html&quot;&gt;currently a draft&lt;/a&gt; - I can recommend reading through the standard since it explains it probably better than I am going to do.&lt;/p&gt;

&lt;p&gt;Let’s dive into these two topics and see how it works:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;First, we look at the post message web API&lt;/li&gt;
  &lt;li&gt;Second, we see how it is used in web message OAuth response mode&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;sending-data-between-different-browser-windows-with-post-message&quot;&gt;Sending data between different browser windows with post message&lt;/h2&gt;

&lt;p&gt;In a nutshell, the post message web API allows you to send and receive data between different browser windows.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage&quot;&gt;MDN has great documentation about post message&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I think this is best understood with an example:&lt;/p&gt;

&lt;p&gt;For our little demo we need two pages: The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parent.html&lt;/code&gt; page, and the popup &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;child.html&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;First the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parent.html&lt;/code&gt; page opens the popup and registers an event listener for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;message&lt;/code&gt; event:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;window.open(&apos;child.html&apos;, &apos;childWindow&apos;, &apos;width=600,height=400&apos;);

// Listen for messages from the child window
window.addEventListener(&apos;message&apos;, (event) =&amp;gt; {
    console.log(&quot;Message&quot;, event?.data)
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;child.html&lt;/code&gt; obtains a reference to the parent window, and uses the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;postMessage&lt;/code&gt; method on it to send it:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// obtain a reference to the parent window
const windowRef = window.opener
windowRef.postMessage({message: &quot;Hello from child page!&quot;}, window.location.origin);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We will see the messages data logged in the parent browser window.&lt;/p&gt;

&lt;p&gt;Now that we understand how to send and receive data through post message, let’s look at how OAuth makes use of it.&lt;/p&gt;

&lt;h2 id=&quot;web-message-response-mode-in-oauth&quot;&gt;Web message response mode in OAuth&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;https://auth0.com/docs/get-started/authentication-and-authorization-flow/authorization-code-flow&quot;&gt;OAuth Authorization Code Flow describes&lt;/a&gt; how the client application receives an authorization code that then is exchanged for a token.&lt;/p&gt;

&lt;p&gt;In the “normal” case, the authorization server redirects the user back to the redirect_uri and attaches the code as a query parameter in the redirect_uri.
This is the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;query&lt;/code&gt; response mode. (The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fragment&lt;/code&gt; response mode attaches the code as part of the &lt;a href=&quot;https://en.wikipedia.org/wiki/URI_fragment&quot;&gt;URL fragment&lt;/a&gt;, so after the hash symbol &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;In contrast, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;web_message&lt;/code&gt; response mode returns the authorization code as a message via the post message interface.&lt;/p&gt;

&lt;p&gt;To test this, we can create a little demo that opens the authorization url of our OAuth identity server via window.open as a popup, and then starts to listen for the code as a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;message&lt;/code&gt; event.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const authorizeUrl = `https://my-idp.com/authorize?response_type=code&amp;amp;response_mode=web_message...` 

window.open(authorizeUrl, &apos;childWindow&apos;, &apos;width=600,height=400&apos;);

// Listen for messages from the child window
window.addEventListener(&apos;message&apos;, (event) =&amp;gt; {
    console.log(&quot;Message&quot;, event?.data)
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is exactly what we did before in our example about post message.&lt;/p&gt;

&lt;h2 id=&quot;complete-flow&quot;&gt;Complete flow&lt;/h2&gt;

&lt;p&gt;To wrap up this post, let’s look at the complete flow.&lt;/p&gt;

&lt;p&gt;The flow will now be like this:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Our application opens the popup with the link to the authorization server.&lt;/li&gt;
  &lt;li&gt;Our application will start listening to the post message event.&lt;/li&gt;
  &lt;li&gt;The user authenticates in the popup.&lt;/li&gt;
  &lt;li&gt;The authorization sends the authorization code back to our application via the post message event.&lt;/li&gt;
  &lt;li&gt;Our application receives the authorization code and exchanges it for the access and id token.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Jakob Zanker</name></author><summary type="html">I recently came across an interesting variation of an OAuth / OpenId Connect authentication flow: OAuth Authentication via a Popup.</summary></entry><entry><title type="html">Inject Environment Variables Into A React App Docker On Runtime</title><link href="http://localhost:4000/inject-environment-variables-into-a-react-app-docker-on-runtime.html" rel="alternate" type="text/html" title="Inject Environment Variables Into A React App Docker On Runtime" /><published>2020-10-26T00:00:00+01:00</published><updated>2020-10-26T00:00:00+01:00</updated><id>http://localhost:4000/inject-environment-variables-into-a-react-app-docker-on-runtime</id><content type="html" xml:base="http://localhost:4000/inject-environment-variables-into-a-react-app-docker-on-runtime.html">&lt;p&gt;In this blog post I want to show you how you can inject environment variables into a React application.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Separating config from code is a good practice&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; for designing applications. For example you need to add config to your front end application, when you have it deployed in different environments, e.g. a staging and a production environment.&lt;/p&gt;

&lt;p&gt;Baking the configuration into the code or the Docker image both violates the principle of separating config from code.&lt;/p&gt;

&lt;p&gt;The solution is to pass as environment variables, e.g. the API URL of the back end, to React when the Docker container starts up.&lt;/p&gt;

&lt;p&gt;But since a React application is just bundled static HTML/JavaScript/CSS, your front end cannot directly pick up the environment variables available on the server side!&lt;/p&gt;

&lt;p&gt;This blog post shows you how you nonetheless can do it:&lt;/p&gt;

&lt;h2 id=&quot;inject-environment-variables-into-a-react-application-on-runtime&quot;&gt;Inject environment variables into a React application on runtime&lt;/h2&gt;

&lt;p&gt;The Create React App documentation gives a hint&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; how to inject configuration into a React application: On the server side, you can set global variables on the window object inside your HTML.&lt;/p&gt;

&lt;p&gt;Here is a step-by-step guide of how what you need to do:&lt;/p&gt;

&lt;p&gt;Firstly, you set the required environment variables on the window object. To do that create a JavaScript file called env_vars.js:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;window.API_URL = &quot;localhost:8080&quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Secondly, the env_vars.js JavaScript is embedded in the HTML of your front end application:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;

&amp;lt;head&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;env_vars.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next, you add a bash script that picks up the environment variables and writes them to the env_vars.js file. After that the bash script it starts to serve the front end.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat &amp;lt;&amp;lt;EOF &amp;gt; /usr/src/app/build/env_vars.js
window.API_URL=&quot;$API_URL&quot;;
EOF

serve -s ./build/ -l 8080
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Finally, set the Dockerfile’s entry point to the bash script:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RUN chmod +x docker-entrypoint.sh

ENTRYPOINT [&quot;/usr/src/app/docker-entrypoint.sh&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That’s it!&lt;/p&gt;

&lt;p&gt;The environment variables inside the Docker container are now made available to the JavaScript running on the client side.&lt;/p&gt;

&lt;h2 id=&quot;run-it-in-docker&quot;&gt;Run it in Docker&lt;/h2&gt;

&lt;p&gt;Now when you start up the Docker container, you can pass a environment variable to React:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -e API_URL=test.myapp.com docker-inject-env-react-runtime
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;github-of-the-demo-project&quot;&gt;GitHub of the Demo project&lt;/h2&gt;

&lt;p&gt;I created a Demo project on GitHub that contains a working example.&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;hr data-content=&quot;footnotes&quot; /&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://12factor.net/config&quot;&gt;https://12factor.net/config&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://create-react-app.dev/docs/title-and-meta-tags/#injecting-data-from-the-server-into-the-page&quot;&gt;https://create-react-app.dev/docs/title-and-meta-tags/#injecting-data-from-the-server-into-the-page&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://github.com/githubjakob/react-inject-env-docker-runtime&quot;&gt;https://github.com/githubjakob/react-inject-env-docker-runtime&lt;/a&gt; &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Jakob Zanker</name></author><summary type="html">In this blog post I want to show you how you can inject environment variables into a React application.</summary></entry><entry><title type="html">Automated Screenshot Comparison Test With Headless Chrome In Bitbucket Pipeline</title><link href="http://localhost:4000/automated-screenshot-comparison-test-with-headless-chrome-in-bitbucket-pipeline.html" rel="alternate" type="text/html" title="Automated Screenshot Comparison Test With Headless Chrome In Bitbucket Pipeline" /><published>2019-09-06T00:00:00+02:00</published><updated>2019-09-06T00:00:00+02:00</updated><id>http://localhost:4000/automated-screenshot-comparison-test-with-headless-chrome-in-bitbucket-pipeline</id><content type="html" xml:base="http://localhost:4000/automated-screenshot-comparison-test-with-headless-chrome-in-bitbucket-pipeline.html">&lt;p&gt;In this blog post I want to show how to set up automated screenshot comparison tests with a headless Chrome browser, using Puppeteer and Pixelmatch, in a Bitbucket pipeline. A simple react application will be used to test.&lt;/p&gt;

&lt;p&gt;Screenshots are taken using Puppeteer and a headless Chrome browser. The screenshots are compared with baseline images using Pixelmatch and a simple helper function. If the actual screenshot matches the baseline image, the test succeeds, otherwise it fails. The react application under test uses a rest backend (which is mocked in the pipeline).&lt;/p&gt;

&lt;p&gt;In the end of the blog post, you’ll find a link to a Github repository that contains a working example of the setup.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;quick-start-run-the-tests-from-the-project-in-github&quot;&gt;Quick start: Run the tests from the project in Github&lt;/h2&gt;

&lt;p&gt;The project contains configuration for the automated browser tests to run in a bitbucket pipeline. The easiest way to run the tests, is to run the bitbucket pipeline locally using&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/githubjakob/react-puppeteer-screenshot-test
npm install -g bbrun
docker build -t node-11-browser .
bbrun --template bitbucket-pipelines.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The run the tests without the bitbucket pipeline, .ie. without bbrun, you can execute each node command separately:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm start
npm run mock
npm run browsertests:mobile
npm run browsertests:desktop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;tips-running-the-tests-in-the-project&quot;&gt;Tips running the tests in the project&lt;/h2&gt;

&lt;p&gt;In case a screenshot is not matching, you can create a diff that shows the non-matching areas. To enable creating a diff set writeDiff to true in BrowserTestUtils.js. This works with and without using bbrun and is disabled by default.&lt;/p&gt;

&lt;p&gt;You can adjust the threshold of how many non-matching pixels result in a failing test. You can also adjust the threshold used by Pixelmatch to determine when a single pixel is counted as failed. See the constants in BrowserTestUtils.js for both thresholds.&lt;/p&gt;

&lt;p&gt;For debugging, you can set headless to false in BrowserTestUtils.js to have Puppeteer start up a Chrome browser (with GUI) for the tests.&lt;/p&gt;

&lt;h2 id=&quot;screenshot-comparison-test-with-puppeteer--pixelmatch-mocked-backend-with-server-json&quot;&gt;Screenshot comparison test with Puppeteer &amp;amp; Pixelmatch, mocked backend with server-json&lt;/h2&gt;

&lt;p&gt;The project contains a basic setup for a screenshot comparison test for a react application. Screenshots are taken with Puppeteer and compared with the expected baseline image using Pixelmatch. The backend for the react application is mocked with server-json.&lt;/p&gt;

&lt;h2 id=&quot;take-screenshots-with-puppeteer&quot;&gt;Take screenshots with Puppeteer&lt;/h2&gt;

&lt;p&gt;Puppeteer provides the API to control a headless Chrome browser. With puppeteer we can open pages, navigate, click on links and take the screenshots. App.test.jsx contains a simple testcase using Jest and Puppeteer that open up the homepage and take a screenshot.&lt;/p&gt;

&lt;h2 id=&quot;compare-screenshots-with-pixelmatch&quot;&gt;Compare screenshots with Pixelmatch&lt;/h2&gt;

&lt;p&gt;Once the screenshot is taken by Puppeteer, we use Pixelmatch to compare the screenshot with the baseline image. BrowserTestUtils.js contains the helper functions to perform the screenshot comparison.&lt;/p&gt;

&lt;p&gt;An alternative to having a customer helper function is using a library like puppeteer-screenshot-tester&lt;/p&gt;

&lt;h2 id=&quot;testing-mobile-and-desktop-viewport-resolution&quot;&gt;Testing mobile and desktop viewport resolution&lt;/h2&gt;

&lt;p&gt;Width and height of the browser viewport are set via env variables. Because of this, we can reuse the same test cases for testing different resolutions. See package.json how the two node scripts npm run browsertests:desktop and npm run browsertests:mobile run the same test but with different env variables width and height set. See also the folder src/browsertests/screenshots how this changes the filename for the baseline images.&lt;/p&gt;

&lt;h2 id=&quot;mocking-the-backend&quot;&gt;Mocking the backend&lt;/h2&gt;

&lt;p&gt;Our test react app assumes a backend to retrieve data with rest calls. For the browsertests we need to mock the backend. For this we use server-json. The json payload for the rest calls is stored in backend-mock/db.json, backend-mock/routes.json allows to map urls to database entries in backend-mock/db.json.&lt;/p&gt;

&lt;h2 id=&quot;run-automated-browsertests-in-bitbucket-pipeline&quot;&gt;Run automated browsertests in Bitbucket pipeline&lt;/h2&gt;

&lt;p&gt;This project includes a bitbucket-pipelines.yml that contains the configuration to run the browsertest in a bitbucket pipeline.&lt;/p&gt;

&lt;h2 id=&quot;send-react-and-mock-process-to-background&quot;&gt;Send react and mock process to background&lt;/h2&gt;

&lt;p&gt;An ampersand (‘&amp;amp;’) is added to the commands so that the process is sent to the background and the commands are run in parallel.&lt;/p&gt;

&lt;p&gt;Even though the npm start process is now in the background the pipeline will finish after the test has finished, i.e. the non-completing react process in the background does not block the whole pipeline: If the test succeeds (fails), the whole pipeline step also succeeds (fails).&lt;/p&gt;

&lt;h2 id=&quot;start-react-without-opening-browser-window&quot;&gt;Start react without opening browser window&lt;/h2&gt;

&lt;p&gt;By default npm start opens a browser window. This will make the pipeline crash. To prevent this we need to start react with BROWSER=none npm start.&lt;/p&gt;

&lt;h2 id=&quot;docker-build-image&quot;&gt;Docker build image&lt;/h2&gt;

&lt;p&gt;To run the puppeteer tests inside a bitbucket pipleine, we need to install the dependencies for Chrome/Puppeteer in the bitbucket build image.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt update &amp;amp;&amp;amp; apt install -y gconf-service libasound2 libatk1.0-0 libc6 libcairo2 libcups2 \
 libdbus-1-3 libexpat1 libfontconfig1 libgcc1 libgconf-2-4 libgdk-pixbuf2.0-0 libglib2.0-0 \
 libgtk-3-0 libnspr4 libpango-1.0-0 libpangocairo-1.0-0 libstdc++6 libx11-6 libx11-xcb1 \
 libxcb1 libxcomposite1 libxcursor1 libxdamage1 libxext6 libxfixes3 libxi6 libxrandr2 \
 libxrender1 libxss1 libxtst6 ca-certificates fonts-liberation libappindicator1 libnss3 lsb-release xdg-utils wget
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can do this either directly in the pipeline or create a docker image that we can reuse. The project contains a Dockfile that we can build and that is used in bitbucket-pipelines.yml:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker build -t node-11-browser .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It is also possible to use an image provided by CircleCI, e.g. circleci/node:jessie-browsers&lt;/p&gt;

&lt;h2 id=&quot;reference-to-the-github-project&quot;&gt;Reference to the Github project&lt;/h2&gt;

&lt;p&gt;https://github.com/githubjakob/react-puppeteer-screenshot-test&lt;/p&gt;</content><author><name>Jakob Zanker</name></author><summary type="html">In this blog post I want to show how to set up automated screenshot comparison tests with a headless Chrome browser, using Puppeteer and Pixelmatch, in a Bitbucket pipeline. A simple react application will be used to test.</summary></entry><entry><title type="html">Single Fluentd Log Stream Per Kubernetes Service</title><link href="http://localhost:4000/single-fluentd-log-stream-per-kubernetes-service.html" rel="alternate" type="text/html" title="Single Fluentd Log Stream Per Kubernetes Service" /><published>2019-08-29T00:00:00+02:00</published><updated>2019-08-29T00:00:00+02:00</updated><id>http://localhost:4000/single-fluentd-log-stream-per-kubernetes-service</id><content type="html" xml:base="http://localhost:4000/single-fluentd-log-stream-per-kubernetes-service.html">&lt;p&gt;In this blog post I show you how to create a single fluentd log stream per kubernetes micro service in AWS CloudWatch.&lt;/p&gt;

&lt;p&gt;I was setting up logging for a kubernetes cluster (Amazon EKS) with fluentd. After I followed the tutorial provided by AWS, I found that the log streams showing in AWS CloudWatch are per container per pod. That means that you cannot see all the logs of a service in one place, because you have your logs from one service distributed over multiple log streams.&lt;/p&gt;

&lt;p&gt;Being new to working with fluentd, it took me quite some time to change the configuration, so that you have all the logs of one service unified in a log stream, which, I think, makes much more sense as a default config. This blog post shows, how to do it.&lt;/p&gt;

&lt;h2 id=&quot;by-default-fluentd-creates-one-log-stream-per-container-per-pod&quot;&gt;By default Fluentd creates one log stream per container per pod&lt;/h2&gt;

&lt;p&gt;If you follow the tutorial on how to set up CloudWatch logging for your AWS EKS cluster with fluentd, which is provided here in the AWS documentation&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, you end up with a fluentd configuration that creates one log stream per container per pod. This has some unpractical implications. E.g. if you restart a pod, the logs of the newly created pod will end up in a separate log stream, as the new pod will get a new id. In CloudWatch it looks like this (it’s just one service called “scraper-worker”, with one replica, but after several restarts, the logs end up in different places):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/fluentd-one-per-pod2.png&quot; alt=&quot;fluentd one log stream per log&quot; /&gt;
&lt;em&gt;One fluentd log stream per container per pod in AWS Cloudwatch – hard to read&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;how-to-create-a-fluentd-log-stream-for-each-k8s-micro-service&quot;&gt;How to create a Fluentd log stream for each k8s micro service&lt;/h2&gt;

&lt;p&gt;You can adapt the fluentd configuration, so that it creates a log stream per service.&lt;/p&gt;

&lt;p&gt;For this edit your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fluentd.yaml&lt;/code&gt; (e.g. the one that is linked in the AWS documentation) and, in the part that corresponds to the fluentd ConfigMap, find the line where the stream_name record of your container logs is set.&lt;/p&gt;

&lt;p&gt;Here you can change the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stream_name&lt;/code&gt;, which is currently set to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;${tag_parts[3]}&lt;/code&gt;. We want to change it to the service name, because it needs to stay constant over pod restarts. For this we can use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;container_name&lt;/code&gt; of the docker image. This placeholder is provided by the fluentd kubernetes metadata plugin&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;, which by default is enabled in the configuration from the AWS documentation. We can access the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;container_name&lt;/code&gt; placeholder with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;${record[&quot;kubernetes&quot;][&quot;container_name&quot;]}&lt;/code&gt;. We also need to set &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;enable_ruby&lt;/code&gt; to true, as described in this issue of the metadata plugin&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;The whole part you need to change now looks like this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;filter **&amp;gt;
  @type record_transformer
  @id filter_containers_stream_transformer
  enable_ruby true
  &amp;lt;record&amp;gt;
    stream_name ${record[&quot;kubernetes&quot;][&quot;container_name&quot;]}
  &amp;lt;/record&amp;gt;
&amp;lt;/filter&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;log-files-in-k8s&quot;&gt;Log files in k8s&lt;/h2&gt;

&lt;p&gt;As you have seen, by default the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stream_name&lt;/code&gt; was set to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;${tag_parts[3]}&lt;/code&gt;. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;${tag_parts[3]}&lt;/code&gt; selects the 4th part of the tag of the log, which results in the long stream name that we see on the screenshot, e.g. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fluentd-cloudwatch-25xcb_amazon-cloudwatch_fluentd-cloudwatch-421aee3d54acbe6be47ac140cc88a71934efc945451963b7b210294e203a740e&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The whole tag is even a bit longer and corresponds to the path and file name of the log file. Kubernetes places the log files for each docker container of each pod in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/var/log/containers&lt;/code&gt; on one of the nodes. As fluentd collects these files, it separates the path and filename by dots, which, for example, leads to the complete tag var.log.containers.&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fluentd-cloudwatch-25xcb_amazon-cloudwatch_fluentd-cloudwatch-421aee3d54acbe6be47ac140cc88a71934efc945451963b7b210294e203a740e.log&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As we can see, the 4th part of the tag (selected by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tag_parts[3]&lt;/code&gt;) consists of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;pod-name&amp;gt;_&amp;lt;namespace&amp;gt;_&amp;lt;container-name-container-id&amp;gt;&lt;/code&gt;. The container-name without the container-id is the part that stays the same for all the services that use the same docker image. That’s why it makes sense to use that as the log stream tag.&lt;/p&gt;

&lt;h2 id=&quot;one-log-stream-per-service-in-aws-cloudwatch&quot;&gt;One log stream per service in AWS CloudWatch&lt;/h2&gt;

&lt;p&gt;After you have changed the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stream_name&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fluentd.yaml&lt;/code&gt;, apply the configmap and restart the pods.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl apply -f fluentd.yaml&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kubectl -n &amp;lt;namespace-of-fluentd-pods&amp;gt; delete pod &amp;lt;pod-names&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Now you have a single fluentd log stream per kubernetes service in AWS CloudWatch. The logs in AWS CloudWatch look much cleaner. All the logs of every service are in one place, in one log stream, even if we restart pods or have multiple replicas.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/fluentd-one-per-pod2.png&quot; alt=&quot;fluentd one log stream per log&quot; /&gt;
&lt;em&gt;One fluentd log stream per service in AWS CloudWatch – so much cleaner!&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Container-Insights-setup-logs.html &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;https://github.com/fabric8io/fluent-plugin-kubernetes_metadata_filter &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;https://github.com/fabric8io/fluent-plugin-kubernetes_metadata_filter/issues/175 &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Jakob Zanker</name></author><summary type="html">In this blog post I show you how to create a single fluentd log stream per kubernetes micro service in AWS CloudWatch.</summary></entry></feed>